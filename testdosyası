const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("SimpleMonadSurvive Bahis ve Ã–dÃ¼l Testi", function () {
  let contract;
  let owner, players = [], bettors = [];
  let entranceFee, ticketPrice, betAmount;
  let eliminatedPlayersArray = [];
  
  before(async function () {
    console.log("ğŸš€ Test ortamÄ± hazÄ±rlanÄ±yor...");
    const accounts = await ethers.getSigners();
    owner = accounts[0];
    
    // 10 oyuncu ve 5 bahisÃ§i ayarla
    players = accounts.slice(1, 11);
    bettors = accounts.slice(11, 16);
    
    // Test deÄŸerlerini ayarla
    entranceFee = ethers.utils.parseEther("0.01");
    ticketPrice = ethers.utils.parseEther("0.005");
    minBetAmount = ethers.utils.parseEther("0.001");
    maxBetAmount = ethers.utils.parseEther("0.01");
    betAmount = ethers.utils.parseEther("0.005");
    const eliminationStartTime = Math.floor(Date.now() / 1000) + 60; // 60 saniye sonra
    const eliminationInterval = 300; // 5 dakika
    
    // SimpleMonadSurvive kontratÄ±nÄ± deploy et
    const ContractFactory = await ethers.getContractFactory("SimpleMonadSurvive");
    contract = await ContractFactory.deploy(
      entranceFee,
      ticketPrice,
      minBetAmount,
      maxBetAmount,
      eliminationStartTime,
      eliminationInterval
    );
    
    await contract.deployed();
    console.log("âœ… Kontrat deploy edildi:", contract.address);
    
    // Havuz oluÅŸtur
    await contract.createPool();
    console.log("âœ… Havuz oluÅŸturuldu, ID: 1");
  });
  
  it("Oyuncular havuza katÄ±labilmeli", async function () {
    // Ä°lk 10 oyuncu havuza katÄ±lÄ±yor
    for (let i = 0; i < players.length; i++) {
      try {
        await contract.connect(players[i]).joinPool({ value: entranceFee });
        console.log(`Oyuncu ${i+1} havuza katÄ±ldÄ±: ${players[i].address}`);
      } catch (error) {
        console.error(`Oyuncu ${i+1} havuza katÄ±lamadÄ±: ${error.message}`);
      }
    }
    
    const activePlayerCount = await contract.getActivePlayerCount();
    console.log(`âœ… ${activePlayerCount} oyuncu havuza katÄ±ldÄ±`);
    // BigNumber karÅŸÄ±laÅŸtÄ±rmasÄ± iÃ§in .toString() kullanÄ±yoruz
    expect(activePlayerCount.toString()).to.equal("10");
  });
  
  it("BahisÃ§iler bahis yapabilmeli", async function () {
    console.log("\nğŸ² BAHÄ°SLER YAPILIYOR");
    
    // Zaman ilerlet - bahis dÃ¶nemini baÅŸlat
    await ethers.provider.send("evm_increaseTime", [60]);
    await ethers.provider.send("evm_mine", []);
    
    // Top 5'e girecek oyuncularÄ± belirleyelim
    const top5Players = players.slice(0, 5);
    console.log("Top 5 oyuncular:", top5Players.map(p => p.address));
    
    // Her bahisÃ§i iÃ§in bir bahis yap
    for (let i = 0; i < bettors.length; i++) {
      try {
        // BahisÃ§i bakiyesi Ã¶ncesi
        const balanceBefore = await ethers.provider.getBalance(bettors[i].address);
        console.log(`BahisÃ§i ${i+1} bakiyesi Ã¶ncesi: ${ethers.utils.formatEther(balanceBefore)} ETH`);
        
        // Hedef oyuncu - 5. bahisÃ§i doÄŸru tahmin yapsÄ±n (top 5'e giren oyuncu)
        const targetIndex = i === 4 ? 4 : (i + 5) % players.length; // 5. bahisÃ§i 5. oyuncuyu tahmin ediyor
        const targetPlayer = players[targetIndex];
        
        // Bahis yap
        await contract.connect(bettors[i]).placeBet(targetPlayer.address, { value: betAmount });
        
        if (i === 4) {
          console.log(`âœ… BahisÃ§i ${i+1} KAZANAN bahis yaptÄ±: Hedef=${targetPlayer.address}`);
        } else {
          console.log(`âœ… BahisÃ§i ${i+1} bahis yaptÄ±: Hedef=${targetPlayer.address}`);
        }
      } catch (error) {
        console.log(`âŒ BahisÃ§i ${i+1} bahis yapamadÄ±: ${error.message}`);
      }
    }
    
    // Toplam bahis miktarÄ±nÄ± kontrol et
    const totalBets = await contract.totalBetFees();
    console.log(`âœ… Toplam bahis miktarÄ±: ${ethers.utils.formatEther(totalBets)} ETH`);
  });
  
  it("Eleme iÅŸlemi doÄŸru sÄ±rayla yapÄ±labilmeli", async function() {
    console.log("\nâš”ï¸ ELEME Ä°ÅLEMÄ° BAÅLIYOR");
    
    // Eleme iÅŸlemini aktif hale getir
    await contract.connect(owner).startAutomaticElimination();
    
    // SÄ±rayla elemeyi gerÃ§ekleÅŸtir - 1 ÅŸampiyon kalacak ÅŸekilde
    // Ã–nce tÃ¼m oyuncularÄ± ele, son oyuncu hariÃ§ (indeks 4 - 5. oyuncu)
    const eliminationOrder = [
      9, 8, 7, 6, // 10-7. sÄ±radakiler
      0, 1, 2, 3, // 6-3. sÄ±radakiler
      5, 
    ];
    
    // Son kalan oyuncular
    const remainingPlayers = [...players];
    
    // Elimizden geldiÄŸi kadar oyuncuyu ele
    for (let i = 0; i < eliminationOrder.length; i++) {
      const playerIndex = eliminationOrder[i];
      try {
        await contract.connect(owner).eliminatePlayer(players[playerIndex].address);
        eliminatedPlayersArray.push(players[playerIndex]);
        remainingPlayers.splice(remainingPlayers.indexOf(players[playerIndex]), 1);
        
        // SÄ±ralamayÄ± belirle
        let rank;
        if (i < 4) rank = 10 - i; // 10,9,8,7. sÄ±ra
        else if (i < 8) rank = 6 - (i - 4); // 6,5,4,3. sÄ±ra
        else rank = 2; // 2. sÄ±ra
        
        console.log(`ğŸ”´ ${rank}. sÄ±rada: ${players[playerIndex].address}`);
      } catch (error) {
        console.log(`âŒ Eleme baÅŸarÄ±sÄ±z: ${error.message}`);
      }
    }
    
    // Kalan son oyuncu (ÅŸampiyon) - burada 2 oyuncu kalÄ±rsa, birini daha elemeye Ã§alÄ±ÅŸalÄ±m
    const activeCount = await contract.getActivePlayerCount();
    console.log(`âœ… Kalan aktif oyuncu sayÄ±sÄ±: ${activeCount}`);
    
    // EÄŸer hala 2 oyuncu kaldÄ±ysa son bir elimizden geleni deneyelim
    if (activeCount.toString() === "2" && remainingPlayers.length === 2) {
      try {
        // Son kalan oyunculardan birini ele
        const playerToEliminate = remainingPlayers[0].address === players[4].address ? 
                                  remainingPlayers[1] : remainingPlayers[0];
        
        await contract.connect(owner).eliminatePlayer(playerToEliminate.address);
        console.log(`ğŸ”´ 2. sÄ±rada: ${playerToEliminate.address}`);
        eliminatedPlayersArray.push(playerToEliminate);
      } catch (error) {
        console.log(`âŒ Son eleme denemesi baÅŸarÄ±sÄ±z: ${error.message}`);
      }
    }
    
    // Åampiyonu kontrol et
    const activePlayersCount = await contract.getActivePlayerCount();
    
    if (activePlayersCount.toString() === "1") {
      // TÃ¼m aktif oyuncularÄ± kontrol edelim
      for (const player of players) {
        const isActive = await contract.isActivePlayer(player.address);
        if (isActive) {
          console.log(`ğŸ† Åampiyon (1. sÄ±rada): ${player.address}`);
          break;
        }
      }
    } else {
      // Hedeflenen ÅŸampiyon 5. oyuncu (indeks 4)
      console.log(`ğŸ† Hedeflenen ÅŸampiyon (hala elimizde deÄŸil): ${players[4].address}`);
    }
  });
  
  it("Havuz tamamlanabilmeli ve Ã¶dÃ¼ller daÄŸÄ±tÄ±labilmeli", async function() {
    console.log("\nğŸ’° HAVUZU TAMAMLAMA VE Ã–DÃœL DAÄITIMI");
    
    // OyuncularÄ±n baÅŸlangÄ±Ã§ bakiyelerini kaydet
    const initialBalances = {};
    
    // Åampiyon bakiyesi - hedeflenen ÅŸampiyon 5. oyuncu (indeks 4)
    const champion = players[4];
    initialBalances[champion.address] = await ethers.provider.getBalance(champion.address);
    console.log(`Åampiyon baÅŸlangÄ±Ã§ bakiyesi: ${ethers.utils.formatEther(initialBalances[champion.address])} ETH`);
    
    // Elenen oyuncularÄ±n bakiyeleri
    for (const player of eliminatedPlayersArray) {
      initialBalances[player.address] = await ethers.provider.getBalance(player.address);
    }
    
    // BahisÃ§ilerin bakiyeleri
    for (const bettor of bettors) {
      initialBalances[bettor.address] = await ethers.provider.getBalance(bettor.address);
      console.log(`BahisÃ§i bakiyesi: ${ethers.utils.formatEther(initialBalances[bettor.address])} ETH`);
    }
    
    // Åu anki aktif oyuncu sayÄ±sÄ±nÄ± kontrol edelim
    const activeCount = await contract.getActivePlayerCount();
    console.log(`Aktif oyuncu sayÄ±sÄ±: ${activeCount}`);
    
    // Havuzu tamamlama yÃ¶ntemleri
    let completed = false;
    
    // YÃ¶ntem 1: Otomatik tamamlama iÃ§in yeterli zaman geÃ§sin
    try {
      // 1 saat ilerlet
      await ethers.provider.send("evm_increaseTime", [3600]);
      await ethers.provider.send("evm_mine", []);
      console.log("Zaman ilerletildi, otomatik tamamlama beklenebilir...");
      
      // Åimdi havuzun tamamlandÄ±ÄŸÄ±nÄ± kontrol et
      const poolInfo = await contract.getPoolInfo();
      if (!poolInfo[0]) { // poolInfo[0] = isActive
        console.log("âœ… Havuz otomatik olarak tamamlandÄ±");
        completed = true;
      }
    } catch (error) {
      console.log("Havuz durumu kontrolÃ¼nde hata:", error.message);
    }
    
    // YÃ¶ntem 2: Son kalan oyuncuyu ele ve havuzu tamamla
    if (!completed && activeCount.toString() === "2") {
      try {
        // Son kalan oyunculardan birini ele
        const activePlayers = [];
        for (const player of players) {
          if (await contract.isActivePlayer(player.address)) {
            activePlayers.push(player);
          }
        }
        
        if (activePlayers.length === 2) {
          // Hedeflenen ÅŸampiyon deÄŸil diÄŸer oyuncuyu ele
          const playerToEliminate = activePlayers[0].address === champion.address ? 
                                    activePlayers[1] : activePlayers[0];
          
          await contract.connect(owner).eliminatePlayer(playerToEliminate.address);
          console.log(`âœ… Son rakip elendi: ${playerToEliminate.address}`);
          
          // Åimdi havuz otomatik olarak tamamlanmÄ±ÅŸ olmalÄ±
          const poolInfo = await contract.getPoolInfo();
          if (!poolInfo[0]) {
            console.log("âœ… Havuz son rakip elendikten sonra tamamlandÄ±");
            completed = true;
          }
        }
      } catch (error) {
        console.log("Son rakip eleme denemesi baÅŸarÄ±sÄ±z:", error.message);
      }
    }
    
    // YÃ¶ntem 3: Acil durum tamamlama fonksiyonu
    if (!completed) {
      try {
        await contract.connect(owner).emergencyCompletePool();
        console.log("âœ… Havuz acil durum fonksiyonu ile tamamlandÄ±");
        completed = true;
      } catch (error) {
        console.log(`âŒ Havuz tamamlama hatasÄ±: ${error.message}`);
      }
    }
    
    // YÃ¶ntem 4: EÄŸer havuzu tamamlayamazsak, test iÃ§in daÄŸÄ±tÄ±m manueli dene
    if (!completed) {
      try {
        await contract.connect(owner).distributeRewards();
        console.log("âœ… Ã–dÃ¼ller manuel olarak daÄŸÄ±tÄ±ldÄ±");
        completed = true;
      } catch (error) {
        console.log(`âŒ Manuel Ã¶dÃ¼l daÄŸÄ±tÄ±mÄ± hatasÄ±: ${error.message}`);
      }
    }
    
    // Ã–dÃ¼lleri kontrol etmek iÃ§in biraz bekleyelim
    await ethers.provider.send("evm_mine", []);
    
    // Son bakiyeleri kontrol et
    console.log("\nğŸ’µ Ã–DÃœL SONRASI BAKÄ°YELER");
    
    // Åampiyon bakiyesi kontrol
    try {
      const championFinalBalance = await ethers.provider.getBalance(champion.address);
      const championDifference = championFinalBalance.sub(initialBalances[champion.address]);
      console.log(`Åampiyon bakiyesi deÄŸiÅŸimi: ${ethers.utils.formatEther(championDifference)} ETH`);
      
      // Åampiyonun Ã¶dÃ¼l almasÄ± gereken miktarÄ± hesapla ve kontrol et
      const totalPool = entranceFee.mul(10); // 10 oyuncu * 0.01 ETH
      const platformFee = totalPool.mul(10).div(100); // %10
      const availablePool = totalPool.sub(platformFee);
      const championReward = availablePool.mul(35).div(100); // %35
      
      console.log(`Beklenen ÅŸampiyon Ã¶dÃ¼lÃ¼: ~${ethers.utils.formatEther(championReward)} ETH`);
      
      // Åampiyonun Ã¶dÃ¼lÃ¼nÃ¼ kontrat Ã¼zerinden sorgula
      try {
        const reward = await contract.playerRewards(champion.address);
        console.log(`Kontrata gÃ¶re ÅŸampiyon Ã¶dÃ¼lÃ¼: ${ethers.utils.formatEther(reward)} ETH`);
        
        // Ã–dÃ¼lÃ¼ talep et
        if (reward.gt(0)) {
          await contract.connect(champion).claimReward();
          console.log("Åampiyon Ã¶dÃ¼lÃ¼ talep edildi");
        }
      } catch (error) {
        console.log("Ã–dÃ¼l bilgisi alÄ±namadÄ±:", error.message);
      }
    } catch (error) {
      console.log("Åampiyon bakiyesi kontrol edilemedi:", error.message);
    }
    
    // Kazanan bahisÃ§i (5. bahisÃ§i) bakiyesi kontrol
    try {
      const winningBettor = bettors[4];
      const betterFinalBalance = await ethers.provider.getBalance(winningBettor.address);
      const betterDifference = betterFinalBalance.sub(initialBalances[winningBettor.address]);
      console.log(`Kazanan bahisÃ§i bakiyesi deÄŸiÅŸimi: ${ethers.utils.formatEther(betterDifference)} ETH`);
    } catch (error) {
      console.log("BahisÃ§i bakiyesi kontrol edilemedi:", error.message);
    }
    
    // Platform Ã¼cretleri
    try {
      const platformFees = await contract.platformFees();
      console.log(`Platform Ã¼cretleri: ${ethers.utils.formatEther(platformFees)} ETH`);
      
      if (platformFees.gt(0)) {
        const ownerInitialBalance = await ethers.provider.getBalance(owner.address);
        
        await contract.connect(owner).withdrawPlatformFees();
        console.log("âœ… Platform Ã¼cretleri Ã§ekildi");
        
        const ownerFinalBalance = await ethers.provider.getBalance(owner.address);
        const ownerDifference = ownerFinalBalance.sub(ownerInitialBalance);
        console.log(`Platform sahibi farkÄ±: ${ethers.utils.formatEther(ownerDifference)} ETH`);
      }
    } catch (error) {
      console.log("Platform Ã¼cretleri kontrol edilemedi:", error.message);
    }
  });
});
